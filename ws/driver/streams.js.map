{"version":3,"file":"streams.js","sourceRoot":"","sources":["streams.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n\n Streams in a WebSocket connection\n ---------------------------------\n\n We model a WebSocket as two duplex streams: one stream is for the wire protocol\n over an I/O socket, and the other is for incoming/outgoing messages.\n\n\n +----------+      +---------+      +----------+\n [1] write(chunk) -->| ~~~~~~~~ +----->| parse() +----->| ~~~~~~~~ +--> emit('data') [2]\n |          |      +----+----+      |          |\n |          |           |           |          |\n |    IO    |           | [5]       | Messages |\n |          |           V           |          |\n |          |      +---------+      |          |\n [4] emit('data') <--+ ~~~~~~~~ |<-----+ frame() |<-----+ ~~~~~~~~ |<-- write(chunk) [3]\n +----------+      +---------+      +----------+\n\n\n Message transfer in each direction is simple: IO receives a byte stream [1] and\n sends this stream for parsing. The parser will periodically emit a complete\n message text on the Messages stream [2]. Similarly, when messages are written\n to the Messages stream [3], they are framed using the WebSocket wire format and\n emitted via IO [4].\n\n There is a feedback loop via [5] since some input from [1] will be things like\n ping, pong and close frames. In these cases the protocol responds by emitting\n responses directly back to [4] rather than emitting messages via [2].\n\n For the purposes of flow control, we consider the sources of each Readable\n stream to be as follows:\n\n * [2] receives input from [1]\n * [4] receives input from [1] and [3]\n\n The classes below express the relationships described above without prescribing\n anything about how parse() and frame() work, other than assuming they emit\n 'data' events to the IO and Messages streams. They will work with any protocol\n driver having these two methods.\n **/\nimport {Stream} from \"node/stream\";\nimport {Base} from \"./base\";\nexport class IO extends Stream {\n\n    public readable:boolean;\n    public writable:boolean;\n    private _driver:Base;\n    public _paused:boolean;\n    private parent:Stream;\n    public constructor(driver) {\n        super();\n        this.readable = this.writable = true;\n        this._paused = false;\n        this._driver = driver;\n        this.on('pipe',(stream)=>{\n            this.parent = stream\n        })\n    }\n\n    public pause() {\n        this._paused = true;\n        this._driver.messages._paused = true;\n    }\n    public resume() {\n        this._paused = false;\n        this.emit('drain');\n        let messages = this._driver.messages;\n        messages._paused = false;\n        messages.emit('drain');\n    }\n    public write(chunk,enc?,callback?) {\n        if (!this.writable) {\n            return false;\n        }\n        this._driver.parse(chunk);\n        return !this._paused;\n    }\n    public end(chunk?) {\n        if (!this.writable) return;\n        if (chunk !== undefined) this.write(chunk);\n        this.writable = false;\n        let messages = this._driver.messages;\n        if (messages.readable) {\n            messages.readable = messages.writable = false;\n            messages.emit('end');\n        }\n    }\n    public destroy() {\n        this.end();\n    }\n}\nexport class Messages extends Stream {\n    public readable:boolean;\n    public writable:boolean;\n    private _driver:Base;\n    public _paused:boolean;\n\n    constructor(driver) {\n        super();\n        this.readable = this.writable = true;\n        this._paused = false;\n        this._driver = driver;\n    }\n    public pause() {\n        //console.info(\"Messages.PAUSE\");\n        this._driver.io._paused = true;\n    }\n    public resume() {\n        //console.info(\"Messages.RESUME\");\n        this._driver.io._paused = false;\n        this._driver.io.emit('drain');\n    }\n    public write(message) {\n        //console.info(\"Messages.write\",message);\n        if (!this.writable){\n            return false;\n        }\n        if (typeof message === 'string'){\n            this._driver.text(message);\n        }else {\n            this._driver.binary(message);\n        }\n        return !this._paused;\n    }\n    public end(message) {\n        if (message !== undefined){\n            this.write(message);\n        }\n    }\n    public destroy() {}\n}\n\n\n\n"]}